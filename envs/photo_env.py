import gymnasium as gym
from gymnasium import spaces
import numpy as np
import logging
import os
from .new_edit_photo import PhotoEditor
from .env_dataloader import create_dataloaders
import torch


# DATASET_DIR = "./dataset/"
# TARGET_DIR = "expertC/"
# ORIGINAL_DIR = "original/"

THRESHOLD = -0.01
class PhotoEnhancementEnv(gym.Env):
    metadata = {
            'render.modes': ['human', 'rgb_array'],
        }
    def __init__(self,
                    batch_size,
                    logger=None,
                    imsize=64,
                    max_episode_steps=10,
                    training_mode=True,
                    pre_encode = True,
                    done_threshold = THRESHOLD
                    ):
            super().__init__()


            self.tags = {'max_episode_steps': max_episode_steps}
            self.logger = logger or logging.getLogger(__name__)
            self.imsize = imsize
            self.batch_size = batch_size
            self.training_mode = training_mode
            self.pre_encode = pre_encode

            self.train_dataloader, self.test_dataloader = create_dataloaders(self.pre_encode)

            self.photo_editor = PhotoEditor()
            self.num_parameters = self.photo_editor.num_parameters

            self.inter_dataloader_count = 0 #counts number of batch of samples seen by the agent
            self.iter_dataloader = iter(self.train_dataloader) #iterator over the dataloader 

            self.action_space = spaces.Dict({
            'parameters':
            spaces.Box(low=-1.0, high=1.0,
                            shape=(self.batch_size, self.num_parameters), dtype=torch.float32),
        })
            if self.pre_encode == True:
                self.observation_space = spaces.Dict({
                     
                'encoded_source':
                spaces.Box(low=-torch.inf,
                        high=+torch.inf,
                        shape=(self.batch_size, self.train.dataset.encoded_source.shape[1]),
                        dtype=np.uint8),

                'encoded_image':spaces.Box(low=-torch.inf,
                        high=+torch.inf,
                        shape=(self.batch_size, self.train.dataset.encoded_source.shape[1]),
                        dtype=torch.uint8),
                
                'source_image':spaces.Box(low=0,
                            high=255,
                            shape=(self.batch_size, 3, self.imsize, self.imsize),
                            dtype=np.uint8),
                'target_image':spaces.Box(low=0,
                            high=255,
                            shape=(self.batch_size, 3, self.imsize, self.imsize),
                            dtype=np.uint8)      
            }
            )
                
            else:

                self.observation_space = spaces.Dict({
                'image':
                spaces.Box(low=0,
                        high=255,
                        shape=(self.batch_size, 3, self.imsize, self.imsize),
                        dtype=np.uint8),

                'enhanced_image':spaces.Box(low=0,
                        high=255,
                        shape=(self.batch_size, 3, self.imsize, self.imsize),
                        dtype=torch.uint8)
            }
            )
            self.done_threshold = done_threshold 
            self.state = None #Batch of images (B,3,H,W) that correspond to the agent state each image can be seen as a sub state in a sub env   
            self.action = None # Batch of actions  (B,N_params)
            self.done = None # Batch of Bool that state wether the the sub env (images) reached the best enhacement
            self.reset()    

    def reset_data_iterator(self,):
         self.iter_dataloader = iter(self.train_dataloader)

    def reset (self):
        self.logger.debug('reset the drawn picture')
        if self.iter_dataloader_count == len(self.iter_dataloader):
            self.reset_data_iterator()
        if self.pre_encode:    
            source_image,target_image,encoded_source,encoded_target = next(self.iter_dataloader) 
            observation = {               
                'encoded_source':encoded_source,
                'encoded_image':encoded_target,           
                'source_image':source_image,
                'target_image':target_image     
            }


        else:
            source_image,target_image = next(self.iter_dataloader) 
            observation = {                     
                'source_image':source_image,
                'target_image':target_image     
            }
        self.state = observation
        return observation
    

    def compute_rewards(self,enhanced_image,target_image):
        """
            args:
                enhanced_image: (Next_State) batch of enhanced images using parameters generated by the agent
                target: batch of target images
        """
        enhanced =torch.flatten(enhanced_image.clone(),start_dim=1, end_dim=-1)
        target = torch.flatten(target_image.clone(),start_dim=1, end_dim=-1)

        rmse = enhanced-target
        rmse = torch.pow(rmse,2).mean(1)
        rmse = torch.sqrt(rmse)
        
        rewards = -rmse

        return rewards

    def check_done(rewards:torch.Tensor,threshold:float):
        """
        Function that check if the enhanced image reached a certain minium threshold of enhancement
            args: 
                rewards: tensor of batch rewards
                threshold: minimum threshold of enhaancement should be a value<0 for the case of rmse
        """
        return rewards>threshold
    def step(self,batch_action:torch.Tensor):
        """
        args:
            batch_action: torch.Tensor with shape (B,N_params) where N_paramas is the number of photo enhancing paramters (N_params = self.num_parameters)

        return:
            observation: Batch observation tensor with shape(B,3,H,W)
            reward : Batch reward tensor with shape (B,)
            done: Bool True if the agent reached acceptable performance False not yet
            info : dict information 
        """
        next_state = self.photo_editor(self.state,batch_action)
        rewards = self.compute_rewards(self.state,next_state)
        done = self.check_done(rewards,self.done_threshold)
        info ={} #not used
        return next_state, rewards, done


